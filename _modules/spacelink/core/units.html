<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>spacelink.core.units &mdash; SpaceLink 0.1.10 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=a6a68382" />
      <link rel="stylesheet" type="text/css" href="../../../_static/fonts.css?v=5583d106" />

  
    <link rel="canonical" href="https://cascade-space-co.github.io/spacelink/_modules/spacelink/core/units.html" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=bafade30"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            SpaceLink
          </a>
              <div class="version">
                0.1.10
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../core/index.html">Core Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../phy/index.html">PHY Modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Usage Examples</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SpaceLink</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">spacelink.core.units</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for spacelink.core.units</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Decibel Units</span>
<span class="sd">-------------</span>

<span class="sd">To create a dimensionless quantity in decibels, use the ``u.dB(1)`` unit rather than</span>
<span class="sd">``u.dB``. For example, ``3.01 * u.dB(1)``. The (1) informs Astropy that the reference</span>
<span class="sd">level is 1, which allows conversion from decibels to linear scale via</span>
<span class="sd">``.to(u.dimensionless)``. A bare ``u.dB`` has no defined reference level and Astropy</span>
<span class="sd">will refuse to convert it to ``u.dimensionless``.</span>

<span class="sd">For quantities with physical dimensions in decibels, use ``u.dB(unit)``. For example,</span>
<span class="sd">``3.01 * u.dB(u.W)``. Or use one of the aliases defined in this module for common cases</span>
<span class="sd">like ``u.dBW`` or ``u.dBm``.</span>

<span class="sd">Wavelength</span>
<span class="sd">----------</span>

<span class="sd">The relationship between wavelength and frequency is given by:</span>

<span class="sd">.. math::</span>
<span class="sd">   \lambda = \frac{c}{f}</span>

<span class="sd">where:</span>

<span class="sd">* :math:`c` is the speed of light (299,792,458 m/s)</span>
<span class="sd">* :math:`f` is the frequency in Hz</span>

<span class="sd">Return Loss to VSWR</span>
<span class="sd">-------------------</span>

<span class="sd">The conversion from return loss in decibels to voltage standing wave ratio (VSWR) is</span>
<span class="sd">done using:</span>

<span class="sd">.. math::</span>
<span class="sd">   \text{VSWR} = \frac{1 + |\Gamma|}{1 - |\Gamma|}</span>

<span class="sd">where:</span>

<span class="sd">* :math:`|\Gamma|` is the magnitude of the reflection coefficient</span>
<span class="sd">* :math:`|\Gamma| = 10^{-\frac{\text{RL}}{20}}`</span>
<span class="sd">* :math:`\text{RL}` is the return loss in dB</span>

<span class="sd">VSWR to Return Loss</span>
<span class="sd">-------------------</span>

<span class="sd">The conversion from voltage standing wave ratio (VSWR) to return loss in decibels is</span>
<span class="sd">done using:</span>

<span class="sd">.. math::</span>
<span class="sd">   \text{RL} = -20 \log_{10}\left(\frac{\text{VSWR} - 1}{\text{VSWR} + 1}\right)</span>

<span class="sd">where:</span>

<span class="sd">* :math:`\text{VSWR}` is the voltage standing wave ratio</span>
<span class="sd">* :math:`\text{RL}` is the return loss in dB</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">inspect</span><span class="w"> </span><span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Annotated</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">get_args</span><span class="p">,</span>
    <span class="n">get_origin</span><span class="p">,</span>
    <span class="n">get_type_hints</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">astropy.constants</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">constants</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">u</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">astropy.units</span><span class="w"> </span><span class="kn">import</span> <span class="n">Quantity</span>

<span class="c1"># Type variable for enforce_units decorator - accepts only functions or classes</span>
<span class="n">FuncOrClass</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;FuncOrClass&quot;</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">type</span><span class="p">)</span>


<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;dBHz&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">u</span><span class="o">.</span><span class="n">dBHz</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;dBW&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">u</span><span class="o">.</span><span class="n">dBW</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">W</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;dBm&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">u</span><span class="o">.</span><span class="n">dBm</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">mW</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;dBK&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">u</span><span class="o">.</span><span class="n">dBK</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;dB_per_K&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">u</span><span class="o">.</span><span class="n">dB_per_K</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">K</span><span class="p">)</span>

<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="s2">&quot;dimensionless&quot;</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
    <span class="n">u</span><span class="o">.</span><span class="n">dimensionless</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span>

<span class="c1"># Using u.dB(1) allows conversion from decibels to u.dimensionless_unscaled. The (1)</span>
<span class="c1"># informs Astropy that the value is decibels relative to 1; without it a bare u.dB has</span>
<span class="c1"># no defined reference point.</span>
<span class="n">Decibels</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">DecibelWatts</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">W</span><span class="p">)]</span>
<span class="n">DecibelMilliwatts</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">mW</span><span class="p">)]</span>
<span class="n">DecibelKelvins</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
<span class="n">DecibelPerKelvin</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">K</span><span class="p">)]</span>
<span class="n">Power</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">W</span><span class="p">]</span>
<span class="n">PowerDensity</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">W</span> <span class="o">/</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">]</span>
<span class="n">Frequency</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">]</span>
<span class="n">Wavelength</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">]</span>
<span class="n">Dimensionless</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dimensionless_unscaled</span><span class="p">]</span>
<span class="n">Distance</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">]</span>
<span class="n">Temperature</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">K</span><span class="p">]</span>
<span class="n">Length</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">]</span>
<span class="n">DecibelHertz</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)]</span>
<span class="n">Angle</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">rad</span><span class="p">]</span>
<span class="n">SolidAngle</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">sr</span><span class="p">]</span>
<span class="n">Time</span> <span class="o">=</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">Quantity</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">s</span><span class="p">]</span>

<span class="c1"># Module-level flag to enable return unit checking (for tests)</span>
<span class="n">_RETURN_UNITS_CHECK_ENABLED</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_annotated_from_hint</span><span class="p">(</span><span class="n">hint</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract Annotated type and unit from a type hint, handling optional parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hint : Any</span>
<span class="sd">        Type hint that may be Annotated directly or a Union containing Annotated</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[type, u.Unit] | None</span>
<span class="sd">        (quantity_type, unit) if Annotated type found, None otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">hint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Check if hint is directly Annotated</span>
    <span class="k">if</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Annotated</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">get_args</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Check if hint is a Union (including PEP 604 X | Y syntax)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="n">Union</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="s2">&quot;UnionType&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">origin</span> <span class="ow">is</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
        <span class="c1"># Look through union arguments for Annotated types</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">get_args</span><span class="p">(</span><span class="n">hint</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Annotated</span><span class="p">:</span>
                <span class="n">annotated_args</span> <span class="o">=</span> <span class="n">get_args</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotated_args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">annotated_args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">annotated_args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_tuple_annotations</span><span class="p">(</span>
    <span class="n">hint</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract annotations from tuple type hints.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hint : Any</span>
<span class="sd">        Type hint that may be a tuple containing Annotated types</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list[tuple[tuple[type, u.Unit] | None, Any]] | None</span>
<span class="sd">        List of ((quantity_type, unit), original_hint) for each tuple element,</span>
<span class="sd">        where the first element is None if not annotated. Returns None if hint is not a</span>
<span class="sd">        tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">get_args</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">annotated_info</span> <span class="o">=</span> <span class="n">_extract_annotated_from_hint</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">annotated_info</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">annotations</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_tuple_return</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expected_annotations</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate tuple return values against their type annotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    result : Any</span>
<span class="sd">        The actual return value (should be a tuple)</span>
<span class="sd">    expected_annotations : list[tuple[tuple[type, u.Unit] | None, Any]]</span>
<span class="sd">        List of ((quantity_type, unit), original_hint) for each tuple element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected tuple return value.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expected_annotations</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Expected tuple with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">expected_annotations</span><span class="p">)</span><span class="si">}</span><span class="s2"> elements, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2"> elements.&quot;</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">original_hint</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
        <span class="nb">zip</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expected_annotations</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Only check annotated elements</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">expected_unit</span> <span class="o">=</span> <span class="n">annotation</span>

            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Check if None is allowed (Optional type)</span>
                <span class="n">origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">original_hint</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                    <span class="n">origin</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Union</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="s2">&quot;UnionType&quot;</span><span class="p">,</span> <span class="p">()))</span>
                    <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">get_args</span><span class="p">(</span><span class="n">original_hint</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;tuple[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] is None but not annotated as Optional.&quot;</span>
                    <span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tuple[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] must be an astropy Quantity.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="n">expected_unit</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;tuple[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] unit </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2"> != annotated </span><span class="si">{</span><span class="n">expected_unit</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_convert_parameter_units</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">expected_unit</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quantity</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a parameter value to the expected unit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Parameter name for error messages</span>
<span class="sd">    value : Any</span>
<span class="sd">        Parameter value to convert</span>
<span class="sd">    expected_unit : u.Unit</span>
<span class="sd">        Expected unit for the parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Quantity</span>
<span class="sd">        Converted quantity with the expected unit</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If value is not a Quantity</span>
<span class="sd">    UnitConversionError</span>
<span class="sd">        If units are incompatible</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Parameter &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; must be provided as an astropy Quantity with unit &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;compatible with </span><span class="si">{</span><span class="n">expected_unit</span><span class="si">}</span><span class="s2">, not a raw number.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Units like deg_C are not automatically convertible to/from K</span>
    <span class="k">if</span> <span class="n">expected_unit</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">temperature</span><span class="p">()):</span>
        <span class="n">equivalencies</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">temperature</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">value</span><span class="o">.</span><span class="n">unit</span> <span class="o">==</span> <span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">:</span>
        <span class="c1"># Allows conversion from u.dB to u.dimensionless_unscaled as if</span>
        <span class="c1"># value.unit was u.dB(1)</span>
        <span class="n">equivalencies</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">logarithmic</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">equivalencies</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">expected_unit</span><span class="p">,</span> <span class="n">equivalencies</span><span class="o">=</span><span class="n">equivalencies</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitConversionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Parameter &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; requires unit compatible with </span><span class="si">{</span><span class="n">expected_unit</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">value</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2">. Original error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_single_return</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">expected_unit</span><span class="p">:</span> <span class="n">u</span><span class="o">.</span><span class="n">Unit</span><span class="p">,</span> <span class="n">ret_hint</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate a single return value against its expected unit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    result : Any</span>
<span class="sd">        The actual return value</span>
<span class="sd">    expected_unit : u.Unit</span>
<span class="sd">        Expected unit for the return value</span>
<span class="sd">    ret_hint : Any</span>
<span class="sd">        Original return type hint for Optional checking</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If result is None when not Optional, or not a Quantity</span>
<span class="sd">    UnitConversionError</span>
<span class="sd">        If units don&#39;t match exactly</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check if None is allowed (Optional type)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">ret_hint</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">origin</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Union</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="s2">&quot;UnionType&quot;</span><span class="p">,</span> <span class="p">()))</span>
            <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">get_args</span><span class="p">(</span><span class="n">ret_hint</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Return value is None but not annotated as Optional.&quot;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Quantity</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Return value must be an astropy Quantity.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">unit</span> <span class="o">!=</span> <span class="n">expected_unit</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">u</span><span class="o">.</span><span class="n">UnitConversionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Return unit </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">unit</span><span class="si">}</span><span class="s2"> != annotated </span><span class="si">{</span><span class="n">expected_unit</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_return_units</span><span class="p">(</span><span class="n">result</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">ret_hint</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Validate return value units based on type hint.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    result : Any</span>
<span class="sd">        The actual return value</span>
<span class="sd">    ret_hint : Any</span>
<span class="sd">        Return type hint</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_RETURN_UNITS_CHECK_ENABLED</span> <span class="ow">or</span> <span class="n">ret_hint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># Try tuple support first</span>
    <span class="n">tuple_annotations</span> <span class="o">=</span> <span class="n">_extract_tuple_annotations</span><span class="p">(</span><span class="n">ret_hint</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tuple_annotations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_validate_tuple_return</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">tuple_annotations</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Single annotated quantity</span>
    <span class="n">annotated_info</span> <span class="o">=</span> <span class="n">_extract_annotated_from_hint</span><span class="p">(</span><span class="n">ret_hint</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">annotated_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">expected_unit</span> <span class="o">=</span> <span class="n">annotated_info</span>
        <span class="n">_validate_single_return</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">expected_unit</span><span class="p">,</span> <span class="n">ret_hint</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_process_parameter</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">hint</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quantity</span> <span class="o">|</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process a single parameter, converting units if needed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Parameter name</span>
<span class="sd">    value : Any</span>
<span class="sd">        Parameter value</span>
<span class="sd">    hint : Any</span>
<span class="sd">        Type hint for the parameter</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Quantity | Any</span>
<span class="sd">        Converted parameter value, or original value if not annotated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">annotated_info</span> <span class="o">=</span> <span class="n">_extract_annotated_from_hint</span><span class="p">(</span><span class="n">hint</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">annotated_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">value</span>  <span class="c1"># Not an annotated parameter</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">expected_unit</span> <span class="o">=</span> <span class="n">annotated_info</span>

    <span class="c1"># Handle None values for optional parameters</span>
    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">_convert_parameter_units</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">expected_unit</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_wrap_function_with_unit_enforcement</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Internal helper to wrap a function with unit enforcement logic.</span>

<span class="sd">    This is the core unit enforcement logic extracted to be reusable</span>
<span class="sd">    for both regular functions and dataclass __init__ methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">bound</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">bound</span><span class="o">.</span><span class="n">apply_defaults</span><span class="p">()</span>

        <span class="c1"># Process all parameters</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">bound</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">hint</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">bound</span><span class="o">.</span><span class="n">arguments</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_process_parameter</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">hint</span><span class="p">)</span>

        <span class="c1"># Execute the function</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">bound</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">bound</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Validate return value units</span>
        <span class="n">_validate_return_units</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;return&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="enforce_units">
<a class="viewcode-back" href="../../../core/units.html#spacelink.core.units.enforce_units">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">enforce_units</span><span class="p">(</span><span class="n">func_or_class</span><span class="p">:</span> <span class="n">FuncOrClass</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FuncOrClass</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decorator to enforce the units specified in function parameter type annotations.</span>

<span class="sd">    This decorator enforces some unit consistency rules for function parameters that</span>
<span class="sd">    annotated with one of the ``Annotated`` types in this module:</span>

<span class="sd">    * The argument must be a ``Quantity`` object.</span>
<span class="sd">    * The argument must be provided with a compatible unit. For example, a ``Frequency``</span>
<span class="sd">      argument&#39;s units can be ``u.Hz``, ``u.MHz``, ``u.GHz``, etc. but not ``u.m``,</span>
<span class="sd">      ``u.K``, or any other non-frequency unit.</span>

<span class="sd">    In addition to the above, the value of any ``Annotated`` argument will be converted</span>
<span class="sd">    automatically to the unit specified in for that type. For example, the ``Angle``</span>
<span class="sd">    type will be converted to ``u.rad``, even if the argument is provided with a unit of</span>
<span class="sd">    ``u.deg``. This allows functions to flexibly handle compatible units while keeping</span>
<span class="sd">    tedious unit conversion logic out of the function body.</span>

<span class="sd">    When applied to a dataclass, this decorator will wrap the ``__init__`` method</span>
<span class="sd">    to enforce units on dataclass field assignments.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func_or_class : callable or class</span>
<span class="sd">        The function or dataclass to wrap.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    callable or class</span>
<span class="sd">        The wrapped function or modified dataclass with unit enforcement.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    UnitConversionError</span>
<span class="sd">        If any argument has incompatible units.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If an ``Annotated`` argument is not an Astropy ``Quantity`` object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check if this is a class</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_or_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">func_or_class</span><span class="p">):</span>
            <span class="c1"># Handle dataclass case: wrap the __init__ method</span>
            <span class="n">original_init</span> <span class="o">=</span> <span class="n">func_or_class</span><span class="o">.</span><span class="fm">__init__</span>
            <span class="n">wrapped_init</span> <span class="o">=</span> <span class="n">_wrap_function_with_unit_enforcement</span><span class="p">(</span><span class="n">original_init</span><span class="p">)</span>
            <span class="n">func_or_class</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">wrapped_init</span>

            <span class="k">return</span> <span class="n">func_or_class</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Regular class - this is probably a mistake</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;@enforce_units should not be applied to regular classes. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Apply it directly to the __init__ method instead:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;class </span><span class="si">{</span><span class="n">func_or_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;    @enforce_units</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;    def __init__(self, ...):</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;        ...&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Handle regular function case</span>
        <span class="k">return</span> <span class="n">_wrap_function_with_unit_enforcement</span><span class="p">(</span><span class="n">func_or_class</span><span class="p">)</span></div>



<div class="viewcode-block" id="wavelength">
<a class="viewcode-back" href="../../../core/units.html#spacelink.core.units.wavelength">[docs]</a>
<span class="nd">@enforce_units</span>
<span class="k">def</span><span class="w"> </span><span class="nf">wavelength</span><span class="p">(</span><span class="n">frequency</span><span class="p">:</span> <span class="n">Frequency</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wavelength</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert frequency to wavelength.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequency : Quantity</span>
<span class="sd">        Frequency quantity (e.g., in Hz)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Quantity</span>
<span class="sd">        Wavelength in meters</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    UnitConversionError</span>
<span class="sd">        If the input quantity has incompatible units</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">frequency</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">Hz</span><span class="p">)</span></div>



<div class="viewcode-block" id="frequency">
<a class="viewcode-back" href="../../../core/units.html#spacelink.core.units.frequency">[docs]</a>
<span class="nd">@enforce_units</span>
<span class="k">def</span><span class="w"> </span><span class="nf">frequency</span><span class="p">(</span><span class="n">wavelength</span><span class="p">:</span> <span class="n">Wavelength</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Frequency</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert wavelength to frequency.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    wavelength : Quantity</span>
<span class="sd">        Wavelength quantity (e.g., in meters)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Quantity</span>
<span class="sd">        Frequency in hertz</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    UnitConversionError</span>
<span class="sd">        If the input quantity has incompatible units</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">constants</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">wavelength</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">m</span><span class="p">)</span></div>



<div class="viewcode-block" id="return_loss_to_vswr">
<a class="viewcode-back" href="../../../core/units.html#spacelink.core.units.return_loss_to_vswr">[docs]</a>
<span class="nd">@enforce_units</span>
<span class="k">def</span><span class="w"> </span><span class="nf">return_loss_to_vswr</span><span class="p">(</span><span class="n">return_loss</span><span class="p">:</span> <span class="n">Dimensionless</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dimensionless</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a return loss in decibels to voltage standing wave ratio (VSWR).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    return_loss : Dimensionless</span>
<span class="sd">        Return loss. Must be &gt;= 1 if provided as dimensionless or &gt;= 0 if provided in</span>
<span class="sd">        decibels. Use np.inf for a perfect match.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dimensionless</span>
<span class="sd">        VSWR (&gt;= 1)</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If return_loss is &lt; 0 dB</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">return_loss</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Return loss must be &gt;= 1.&quot;</span><span class="p">)</span>

    <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">return_loss</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">gamma</span><span class="p">)</span></div>



<div class="viewcode-block" id="vswr_to_return_loss">
<a class="viewcode-back" href="../../../core/units.html#spacelink.core.units.vswr_to_return_loss">[docs]</a>
<span class="nd">@enforce_units</span>
<span class="k">def</span><span class="w"> </span><span class="nf">vswr_to_return_loss</span><span class="p">(</span><span class="n">vswr</span><span class="p">:</span> <span class="n">Dimensionless</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decibels</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert voltage standing wave ratio (VSWR) to return loss in decibels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vswr : Quantity</span>
<span class="sd">        VSWR value (&gt;= 1). Use 1 for a perfect match (infinite return loss)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Quantity</span>
<span class="sd">        Return loss in decibels</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If vswr is less than 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">vswr</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;VSWR must be &gt;= 1.&quot;</span><span class="p">)</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">vswr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">vswr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">dB</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span></div>



<div class="viewcode-block" id="safe_negate">
<a class="viewcode-back" href="../../../core/units.html#spacelink.core.units.safe_negate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">safe_negate</span><span class="p">(</span><span class="n">quantity</span><span class="p">:</span> <span class="n">Quantity</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Quantity</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Safely negate a dB or function unit quantity, preserving the unit.</span>
<span class="sd">    Astropy does not allow direct negation of function units (like dB).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">quantity</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="n">quantity</span><span class="o">.</span><span class="n">unit</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Cascade Space.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>